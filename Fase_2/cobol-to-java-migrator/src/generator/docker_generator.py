"""
Docker Generator - Genera la configurazione Docker per il progetto Java
"""

from typing import Dict, List, Any
from loguru import logger


class DockerGenerator:
    """Genera i file di configurazione Docker per il progetto migrato"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.base_image = config.get('docker', {}).get('base_image', 'openjdk:11-jre-slim')
        self.expose_port = config.get('docker', {}).get('expose_port', 8080)
        self.java_version = config.get('migration', {}).get('target_java_version', '11')
        
    def generate(self, java_project: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Genera tutti i file Docker necessari"""
        logger.info("Generazione configurazione Docker")
        
        docker_files = []
        project_name = java_project.get('project_name', 'migrated-app')
        
        # 1. Dockerfile principale
        dockerfile = self._generate_dockerfile(project_name)
        docker_files.append({
            'filename': 'Dockerfile',
            'content': dockerfile
        })
        
        # 2. Dockerfile multi-stage (ottimizzato)
        dockerfile_multistage = self._generate_dockerfile_multistage(project_name)
        docker_files.append({
            'filename': 'Dockerfile.multistage',
            'content': dockerfile_multistage
        })
        
        # 3. docker-compose.yml per sviluppo
        docker_compose = self._generate_docker_compose(project_name)
        docker_files.append({
            'filename': 'docker-compose.yml',
            'content': docker_compose
        })
        
        # 4. docker-compose.prod.yml per produzione
        docker_compose_prod = self._generate_docker_compose_prod(project_name)
        docker_files.append({
            'filename': 'docker-compose.prod.yml',
            'content': docker_compose_prod
        })
        
        # 5. .dockerignore
        dockerignore = self._generate_dockerignore()
        docker_files.append({
            'filename': '.dockerignore',
            'content': dockerignore
        })
        
        # 6. Script di utility Docker
        docker_scripts = self._generate_docker_scripts(project_name)
        docker_files.extend(docker_scripts)
        
        # 7. File di configurazione per Kubernetes (opzionale)
        k8s_files = self._generate_kubernetes_files(project_name)
        docker_files.extend(k8s_files)
        
        logger.info(f"Generati {len(docker_files)} file Docker")
        
        return docker_files
    
    def _generate_dockerfile(self, project_name: str) -> str:
        """Genera il Dockerfile principale"""
        return f"""# Dockerfile for {project_name}
# Generated by COBOL to Java Migration Tool

FROM {self.base_image}

# Metadata
LABEL maintainer="migrated-from-cobol"
LABEL description="Java application migrated from COBOL"
LABEL version="1.0.0"

# Create app directory
WORKDIR /app

# Create a non-root user to run the application
RUN groupadd -r appuser && useradd -r -g appuser appuser

# Copy the JAR file
ARG JAR_FILE=build/libs/*.jar
COPY ${{JAR_FILE}} app.jar

# Create directories for logs and temp files
RUN mkdir -p /app/logs /app/temp && \\
    chown -R appuser:appuser /app

# Install additional tools if needed
RUN apt-get update && apt-get install -y \\
    curl \\
    netcat \\
    && rm -rf /var/lib/apt/lists/*

# Copy wait-for-it script for database readiness
COPY docker/wait-for-it.sh /wait-for-it.sh
RUN chmod +x /wait-for-it.sh

# Switch to non-root user
USER appuser

# JVM options for container environment
ENV JAVA_OPTS="-Xmx512m -Xms256m -XX:+UseG1GC -XX:MaxGCPauseMillis=100"

# Spring profiles
ENV SPRING_PROFILES_ACTIVE=docker

# Expose port
EXPOSE {self.expose_port}

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \\
    CMD curl -f http://localhost:{self.expose_port}/actuator/health || exit 1

# Run the application
ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -Djava.security.egd=file:/dev/./urandom -jar /app/app.jar"]
"""
    
    def _generate_dockerfile_multistage(self, project_name: str) -> str:
        """Genera un Dockerfile multi-stage ottimizzato"""
        return f"""# Multi-stage Dockerfile for {project_name}
# Generated by COBOL to Java Migration Tool

# Stage 1: Build
FROM gradle:7.6.1-jdk{self.java_version} AS builder

WORKDIR /app

# Copy gradle files first for better caching
COPY build.gradle settings.gradle gradle.properties ./
COPY gradle ./gradle

# Download dependencies (cached if build files don't change)
RUN gradle dependencies --no-daemon

# Copy source code
COPY src ./src

# Build the application
RUN gradle build --no-daemon -x test

# Stage 2: Runtime
FROM {self.base_image}

# Metadata
LABEL maintainer="migrated-from-cobol"
LABEL description="Java application migrated from COBOL"
LABEL version="1.0.0"

# Install required packages
RUN apt-get update && apt-get install -y \\
    curl \\
    netcat \\
    dumb-init \\
    && rm -rf /var/lib/apt/lists/*

# Create app user and directory
RUN groupadd -r appuser && useradd -r -g appuser appuser
WORKDIR /app

# Copy JAR from builder stage
COPY --from=builder /app/build/libs/*.jar app.jar

# Create necessary directories
RUN mkdir -p /app/logs /app/temp /app/config && \\
    chown -R appuser:appuser /app

# Copy additional files
COPY --chown=appuser:appuser docker/wait-for-it.sh /wait-for-it.sh
RUN chmod +x /wait-for-it.sh

# Switch to non-root user
USER appuser

# JVM options optimized for containers
ENV JAVA_OPTS="-XX:+UseContainerSupport \\
    -XX:MaxRAMPercentage=75.0 \\
    -XX:InitialRAMPercentage=50.0 \\
    -XX:+UseG1GC \\
    -XX:MaxGCPauseMillis=100 \\
    -XX:+ParallelRefProcEnabled \\
    -Djava.security.egd=file:/dev/./urandom \\
    -Dfile.encoding=UTF-8"

ENV SPRING_PROFILES_ACTIVE=docker

# Expose port
EXPOSE {self.expose_port}

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \\
    CMD curl -f http://localhost:{self.expose_port}/actuator/health || exit 1

# Use dumb-init to handle signals properly
ENTRYPOINT ["dumb-init", "--"]

# Run the application
CMD ["sh", "-c", "exec java $JAVA_OPTS -jar app.jar"]
"""
    
    def _generate_docker_compose(self, project_name: str) -> str:
        """Genera docker-compose.yml per sviluppo"""
        return f"""# Docker Compose for development
# Generated by COBOL to Java Migration Tool

version: '3.8'

services:
  # Database PostgreSQL
  postgres:
    image: postgres:14-alpine
    container_name: {project_name}-postgres
    environment:
      POSTGRES_DB: banca
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      PGDATA: /var/lib/postgresql/data/pgdata
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./docker/init-scripts:/docker-entrypoint-initdb.d
    networks:
      - app-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Applicazione Spring Boot
  app:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: {project_name}-app
    depends_on:
      postgres:
        condition: service_healthy
    environment:
      SPRING_PROFILES_ACTIVE: docker
      SPRING_DATASOURCE_URL: jdbc:postgresql://postgres:5432/banca
      SPRING_DATASOURCE_USERNAME: postgres
      SPRING_DATASOURCE_PASSWORD: postgres
      LOGGING_LEVEL_ROOT: INFO
      LOGGING_LEVEL_COM_BANK: DEBUG
    ports:
      - "{self.expose_port}:{self.expose_port}"
    networks:
      - app-network
    volumes:
      - ./logs:/app/logs
      - ./config:/app/config:ro
    command: ["/wait-for-it.sh", "postgres:5432", "--", "java", "-jar", "app.jar"]

  # pgAdmin per gestione database (opzionale)
  pgadmin:
    image: dpage/pgadmin4:latest
    container_name: {project_name}-pgadmin
    environment:
      PGADMIN_DEFAULT_EMAIL: admin@example.com
      PGADMIN_DEFAULT_PASSWORD: admin
      PGADMIN_CONFIG_SERVER_MODE: 'False'
    ports:
      - "5050:80"
    networks:
      - app-network
    depends_on:
      - postgres
    volumes:
      - pgadmin_data:/var/lib/pgadmin

  # Redis per caching (opzionale)
  redis:
    image: redis:7-alpine
    container_name: {project_name}-redis
    ports:
      - "6379:6379"
    networks:
      - app-network
    volumes:
      - redis_data:/data
    command: redis-server --appendonly yes

volumes:
  postgres_data:
    driver: local
  pgadmin_data:
    driver: local
  redis_data:
    driver: local

networks:
  app-network:
    driver: bridge
    name: {project_name}-network
"""
    
    def _generate_docker_compose_prod(self, project_name: str) -> str:
        """Genera docker-compose.prod.yml per produzione"""
        return f"""# Docker Compose for production
# Generated by COBOL to Java Migration Tool

version: '3.8'

services:
  # Database PostgreSQL con configurazione produzione
  postgres:
    image: postgres:14-alpine
    container_name: {project_name}-postgres-prod
    restart: always
    environment:
      POSTGRES_DB: ${{DB_NAME:-banca}}
      POSTGRES_USER: ${{DB_USER:-postgres}}
      POSTGRES_PASSWORD: ${{DB_PASSWORD}}
      POSTGRES_INITDB_ARGS: "--encoding=UTF8 --locale=it_IT.utf8"
      PGDATA: /var/lib/postgresql/data/pgdata
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./backup:/backup
    networks:
      - app-network
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 2G
        reservations:
          cpus: '1'
          memory: 1G
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $$POSTGRES_USER"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Applicazione Spring Boot
  app:
    image: ${{DOCKER_REGISTRY:-docker.io}}/{project_name}:${{VERSION:-latest}}
    container_name: {project_name}-app-prod
    restart: always
    depends_on:
      postgres:
        condition: service_healthy
    environment:
      SPRING_PROFILES_ACTIVE: prod
      SPRING_DATASOURCE_URL: jdbc:postgresql://postgres:5432/${{DB_NAME:-banca}}
      SPRING_DATASOURCE_USERNAME: ${{DB_USER:-postgres}}
      SPRING_DATASOURCE_PASSWORD: ${{DB_PASSWORD}}
      SPRING_JPA_HIBERNATE_DDL_AUTO: validate
      SERVER_PORT: {self.expose_port}
      MANAGEMENT_ENDPOINTS_WEB_EXPOSURE_INCLUDE: health,info,metrics,prometheus
      LOGGING_LEVEL_ROOT: WARN
      LOGGING_LEVEL_COM_BANK: INFO
      # Security
      SPRING_SECURITY_USER_NAME: ${{APP_USER:-admin}}
      SPRING_SECURITY_USER_PASSWORD: ${{APP_PASSWORD}}
      # JVM tuning per produzione
      JAVA_OPTS: "-Xmx1g -Xms512m -XX:+UseG1GC -XX:MaxGCPauseMillis=200"
    ports:
      - "${{APP_PORT:-{self.expose_port}}}:{self.expose_port}"
    networks:
      - app-network
    volumes:
      - ./logs:/app/logs
      - ./config:/app/config:ro
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 2G
        reservations:
          cpus: '0.5'
          memory: 512M
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:{self.expose_port}/actuator/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # Nginx come reverse proxy
  nginx:
    image: nginx:alpine
    container_name: {project_name}-nginx
    restart: always
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/ssl:/etc/nginx/ssl:ro
      - nginx_logs:/var/log/nginx
    depends_on:
      - app
    networks:
      - app-network

  # Prometheus per metriche
  prometheus:
    image: prom/prometheus:latest
    container_name: {project_name}-prometheus
    restart: always
    volumes:
      - ./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml:ro
      - prometheus_data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/usr/share/prometheus/console_libraries'
      - '--web.console.templates=/usr/share/prometheus/consoles'
    ports:
      - "9090:9090"
    networks:
      - app-network

  # Grafana per visualizzazione metriche
  grafana:
    image: grafana/grafana:latest
    container_name: {project_name}-grafana
    restart: always
    environment:
      GF_SECURITY_ADMIN_USER: ${{GRAFANA_USER:-admin}}
      GF_SECURITY_ADMIN_PASSWORD: ${{GRAFANA_PASSWORD}}
      GF_INSTALL_PLUGINS: grafana-piechart-panel
    volumes:
      - grafana_data:/var/lib/grafana
      - ./grafana/provisioning:/etc/grafana/provisioning
    ports:
      - "3000:3000"
    networks:
      - app-network
    depends_on:
      - prometheus

volumes:
  postgres_data:
    driver: local
  prometheus_data:
    driver: local
  grafana_data:
    driver: local
  nginx_logs:
    driver: local

networks:
  app-network:
    driver: bridge
    name: {project_name}-network
"""
    
    def _generate_dockerignore(self) -> str:
        """Genera .dockerignore"""
        return """# Docker ignore file
# Generated by COBOL to Java Migration Tool

# Git
.git
.gitignore
.gitattributes

# IDE
.idea
.vscode
*.iml
*.ipr
*.iws
.project
.settings
.classpath

# Build directories
build/
target/
out/
bin/
.gradle/

# Logs
logs/
*.log

# OS files
.DS_Store
Thumbs.db

# Documentation
docs/
*.md
!README.md

# Test files
src/test/
*.test.*

# Docker files (prevent recursive copy)
Dockerfile*
docker-compose*.yml
.dockerignore

# Kubernetes files
k8s/
*.yaml
*.yml
!application.yml
!application-*.yml

# Temporary files
*.tmp
*.temp
*.swp
*~

# Local configuration
application-local.yml
application-local.properties
.env
.env.local

# Gradle wrapper jar (will be downloaded)
!gradle/wrapper/gradle-wrapper.jar
"""
    
    def _generate_docker_scripts(self, project_name: str) -> List[Dict[str, Any]]:
        """Genera script di utility Docker"""
        scripts = []
        
        # 1. wait-for-it.sh
        wait_for_it = """#!/usr/bin/env bash
# wait-for-it.sh - Wait for a service to be ready

set -e

host="$1"
shift
cmd="$@"

until nc -z "$host"; do
  >&2 echo "Waiting for $host to be ready..."
  sleep 1
done

>&2 echo "$host is up - executing command"
exec $cmd
"""
        scripts.append({
            'filename': 'docker/wait-for-it.sh',
            'content': wait_for_it,
            'executable': True
        })
        
        # 2. docker-build.sh
        docker_build = f"""#!/bin/bash
# Build Docker image
# Generated by COBOL to Java Migration Tool

set -e

echo "Building {project_name}..."

# Build JAR
echo "Building JAR with Gradle..."
./gradlew clean build -x test

# Build Docker image
echo "Building Docker image..."
docker build -t {project_name}:latest .

# Tag with version if provided
if [ "$1" ]; then
    docker tag {project_name}:latest {project_name}:$1
    echo "Tagged as {project_name}:$1"
fi

echo "Build complete!"
"""
        scripts.append({
            'filename': 'docker/build.sh',
            'content': docker_build,
            'executable': True
        })
        
        # 3. docker-run.sh
        docker_run = f"""#!/bin/bash
# Run Docker containers
# Generated by COBOL to Java Migration Tool

set -e

# Load environment variables
if [ -f .env ]; then
    export $(cat .env | grep -v '^#' | xargs)
fi

# Choose compose file
COMPOSE_FILE="docker-compose.yml"
if [ "$1" == "prod" ]; then
    COMPOSE_FILE="docker-compose.prod.yml"
fi

echo "Starting containers using $COMPOSE_FILE..."

# Start containers
docker-compose -f $COMPOSE_FILE up -d

# Show logs
docker-compose -f $COMPOSE_FILE logs -f
"""
        scripts.append({
            'filename': 'docker/run.sh',
            'content': docker_run,
            'executable': True
        })
        
        # 4. backup-db.sh
        backup_db = f"""#!/bin/bash
# Backup PostgreSQL database
# Generated by COBOL to Java Migration Tool

set -e

BACKUP_DIR="./backup"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="$BACKUP_DIR/backup_$TIMESTAMP.sql"

# Create backup directory if not exists
mkdir -p $BACKUP_DIR

echo "Creating database backup..."

# Run backup
docker-compose exec -T postgres pg_dump -U postgres banca > $BACKUP_FILE

# Compress backup
gzip $BACKUP_FILE

echo "Backup created: $BACKUP_FILE.gz"

# Remove old backups (keep last 7 days)
find $BACKUP_DIR -name "backup_*.sql.gz" -mtime +7 -delete

echo "Backup complete!"
"""
        scripts.append({
            'filename': 'docker/backup-db.sh',
            'content': backup_db,
            'executable': True
        })
        
        return scripts
    
    def _generate_kubernetes_files(self, project_name: str) -> List[Dict[str, Any]]:
        """Genera file di configurazione Kubernetes (opzionale)"""
        k8s_files = []
        
        # 1. Deployment
        deployment = f"""# Kubernetes Deployment
# Generated by COBOL to Java Migration Tool
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {project_name}
  labels:
    app: {project_name}
spec:
  replicas: 3
  selector:
    matchLabels:
      app: {project_name}
  template:
    metadata:
      labels:
        app: {project_name}
    spec:
      containers:
      - name: {project_name}
        image: {project_name}:latest
        ports:
        - containerPort: {self.expose_port}
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: "prod,k8s"
        - name: SPRING_DATASOURCE_URL
          valueFrom:
            secretKeyRef:
              name: {project_name}-secrets
              key: db-url
        - name: SPRING_DATASOURCE_USERNAME
          valueFrom:
            secretKeyRef:
              name: {project_name}-secrets
              key: db-username
        - name: SPRING_DATASOURCE_PASSWORD
          valueFrom:
            secretKeyRef:
              name: {project_name}-secrets
              key: db-password
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "1Gi"
            cpu: "1000m"
        livenessProbe:
          httpGet:
            path: /actuator/health/liveness
            port: {self.expose_port}
          initialDelaySeconds: 60
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /actuator/health/readiness
            port: {self.expose_port}
          initialDelaySeconds: 30
          periodSeconds: 5
"""
        k8s_files.append({
            'filename': 'k8s/deployment.yaml',
            'content': deployment
        })
        
        # 2. Service
        service = f"""# Kubernetes Service
# Generated by COBOL to Java Migration Tool
apiVersion: v1
kind: Service
metadata:
  name: {project_name}-service
spec:
  selector:
    app: {project_name}
  ports:
    - protocol: TCP
      port: 80
      targetPort: {self.expose_port}
  type: LoadBalancer
"""
        k8s_files.append({
            'filename': 'k8s/service.yaml',
            'content': service
        })
        
        # 3. ConfigMap
        configmap = f"""# Kubernetes ConfigMap
# Generated by COBOL to Java Migration Tool
apiVersion: v1
kind: ConfigMap
metadata:
  name: {project_name}-config
data:
  application.properties: |
    server.port={self.expose_port}
    spring.application.name={project_name}
    management.endpoints.web.exposure.include=health,info,metrics,prometheus
    logging.level.root=INFO
"""
        k8s_files.append({
            'filename': 'k8s/configmap.yaml',
            'content': configmap
        })
        
        # 4. Secrets template
        secrets = f"""# Kubernetes Secrets (template)
# Generated by COBOL to Java Migration Tool
# IMPORTANT: Don't commit actual secrets to version control!
apiVersion: v1
kind: Secret
metadata:
  name: {project_name}-secrets
type: Opaque
stringData:
  db-url: "jdbc:postgresql://postgres-service:5432/banca"
  db-username: "postgres"
  db-password: "CHANGE_ME"
"""
        k8s_files.append({
            'filename': 'k8s/secrets-template.yaml',
            'content': secrets
        })
        
        # 5. HorizontalPodAutoscaler
        hpa = f"""# Kubernetes HorizontalPodAutoscaler
# Generated by COBOL to Java Migration Tool
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: {project_name}-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: {project_name}
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
"""
        k8s_files.append({
            'filename': 'k8s/hpa.yaml',
            'content': hpa
        })
        
        return k8s_files